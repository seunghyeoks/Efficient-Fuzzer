// ======================================================================
// \title  CommandDispatcherTesterBase.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for CommandDispatcher component test harness base class
// ======================================================================

#include <cstdlib>
#include <cstring>

#include "F-Prime/Svc/CmdDispatcher/CommandDispatcherTesterBase.hpp"

namespace Svc {

  // ----------------------------------------------------------------------
  // Component initialization
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    init(FwEnumStoreType instance)
  {
    // Initialize base class
    Fw::PassiveComponentBase::init(instance);

    // Connect input port CmdReg
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_CmdReg());
      port++
    ) {
      this->m_from_CmdReg[port].init();
      this->m_from_CmdReg[port].addCallComp(
        this,
        from_CmdReg_static
      );
      this->m_from_CmdReg[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_CmdReg[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_CmdReg[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port CmdStatus
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_CmdStatus());
      port++
    ) {
      this->m_from_CmdStatus[port].init();
      this->m_from_CmdStatus[port].addCallComp(
        this,
        from_CmdStatus_static
      );
      this->m_from_CmdStatus[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_CmdStatus[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_CmdStatus[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port Log
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_Log());
      port++
    ) {
      this->m_from_Log[port].init();
      this->m_from_Log[port].addCallComp(
        this,
        from_Log_static
      );
      this->m_from_Log[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_Log[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_Log[port].setObjName(portName.toChar());
#endif
    }

#if FW_ENABLE_TEXT_LOGGING == 1
    // Connect input port LogText
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_LogText());
      port++
    ) {
      this->m_from_LogText[port].init();
      this->m_from_LogText[port].addCallComp(
        this,
        from_LogText_static
      );
      this->m_from_LogText[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_LogText[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_LogText[port].setObjName(portName.toChar());
#endif
    }
#endif

    // Connect input port Time
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_Time());
      port++
    ) {
      this->m_from_Time[port].init();
      this->m_from_Time[port].addCallComp(
        this,
        from_Time_static
      );
      this->m_from_Time[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_Time[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_Time[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port Tlm
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_Tlm());
      port++
    ) {
      this->m_from_Tlm[port].init();
      this->m_from_Tlm[port].addCallComp(
        this,
        from_Tlm_static
      );
      this->m_from_Tlm[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_Tlm[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_Tlm[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port compCmdSend
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_compCmdSend());
      port++
    ) {
      this->m_from_compCmdSend[port].init();
      this->m_from_compCmdSend[port].addCallComp(
        this,
        from_compCmdSend_static
      );
      this->m_from_compCmdSend[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_compCmdSend[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_compCmdSend[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port pingOut
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_pingOut());
      port++
    ) {
      this->m_from_pingOut[port].init();
      this->m_from_pingOut[port].addCallComp(
        this,
        from_pingOut_static
      );
      this->m_from_pingOut[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_pingOut[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_pingOut[port].setObjName(portName.toChar());
#endif
    }

    // Connect input port seqCmdStatus
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_from_seqCmdStatus());
      port++
    ) {
      this->m_from_seqCmdStatus[port].init();
      this->m_from_seqCmdStatus[port].addCallComp(
        this,
        from_seqCmdStatus_static
      );
      this->m_from_seqCmdStatus[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_from_seqCmdStatus[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_from_seqCmdStatus[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port CmdDisp
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_CmdDisp());
      port++
    ) {
      this->m_to_CmdDisp[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_CmdDisp[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_CmdDisp[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port compCmdReg
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_compCmdReg());
      port++
    ) {
      this->m_to_compCmdReg[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_compCmdReg[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_compCmdReg[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port compCmdStat
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_compCmdStat());
      port++
    ) {
      this->m_to_compCmdStat[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_compCmdStat[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_compCmdStat[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port pingIn
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_pingIn());
      port++
    ) {
      this->m_to_pingIn[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_pingIn[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_pingIn[port].setObjName(portName.toChar());
#endif
    }

    // Connect output port seqCmdBuff
    for (
      FwIndexType port = 0;
      port < static_cast<FwIndexType>(this->getNum_to_seqCmdBuff());
      port++
    ) {
      this->m_to_seqCmdBuff[port].init();

#if FW_OBJECT_NAMES == 1
      Fw::ObjectName portName;
      portName.format(
        "%s_to_seqCmdBuff[%" PRI_PlatformIntType "]",
        this->m_objName.toChar(),
        port
      );
      this->m_to_seqCmdBuff[port].setObjName(portName.toChar());
#endif
    }
  }

  // ----------------------------------------------------------------------
  // Connectors for to ports
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    connect_to_CmdDisp(
        FwIndexType portNum,
        Fw::InputCmdPort* port
    )
  {
    FW_ASSERT(
      portNum < this->getNum_to_CmdDisp(),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_CmdDisp[portNum].addCallPort(port);
  }

  void CommandDispatcherTesterBase ::
    connect_to_compCmdReg(
        FwIndexType portNum,
        Fw::InputCmdRegPort* port
    )
  {
    FW_ASSERT(
      portNum < this->getNum_to_compCmdReg(),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_compCmdReg[portNum].addCallPort(port);
  }

  void CommandDispatcherTesterBase ::
    connect_to_compCmdStat(
        FwIndexType portNum,
        Fw::InputCmdResponsePort* port
    )
  {
    FW_ASSERT(
      portNum < this->getNum_to_compCmdStat(),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_compCmdStat[portNum].addCallPort(port);
  }

  void CommandDispatcherTesterBase ::
    connect_to_pingIn(
        FwIndexType portNum,
        Svc::InputPingPort* port
    )
  {
    FW_ASSERT(
      portNum < this->getNum_to_pingIn(),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_pingIn[portNum].addCallPort(port);
  }

  void CommandDispatcherTesterBase ::
    connect_to_seqCmdBuff(
        FwIndexType portNum,
        Fw::InputComPort* port
    )
  {
    FW_ASSERT(
      portNum < this->getNum_to_seqCmdBuff(),
      static_cast<FwAssertArgType>(portNum)
    );

    this->m_to_seqCmdBuff[portNum].addCallPort(port);
  }

  // ----------------------------------------------------------------------
  // Getters for from ports
  // ----------------------------------------------------------------------

  Fw::InputCmdRegPort* CommandDispatcherTesterBase ::
    get_from_CmdReg(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_CmdReg(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_CmdReg[portNum];
  }

  Fw::InputCmdResponsePort* CommandDispatcherTesterBase ::
    get_from_CmdStatus(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_CmdStatus(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_CmdStatus[portNum];
  }

  Fw::InputLogPort* CommandDispatcherTesterBase ::
    get_from_Log(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_Log(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_Log[portNum];
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  Fw::InputLogTextPort* CommandDispatcherTesterBase ::
    get_from_LogText(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_LogText(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_LogText[portNum];
  }

#endif

  Fw::InputTimePort* CommandDispatcherTesterBase ::
    get_from_Time(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_Time(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_Time[portNum];
  }

  Fw::InputTlmPort* CommandDispatcherTesterBase ::
    get_from_Tlm(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_Tlm(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_Tlm[portNum];
  }

  Fw::InputCmdPort* CommandDispatcherTesterBase ::
    get_from_compCmdSend(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_compCmdSend(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_compCmdSend[portNum];
  }

  Svc::InputPingPort* CommandDispatcherTesterBase ::
    get_from_pingOut(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_pingOut(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_pingOut[portNum];
  }

  Fw::InputCmdResponsePort* CommandDispatcherTesterBase ::
    get_from_seqCmdStatus(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_from_seqCmdStatus(),
      static_cast<FwAssertArgType>(portNum)
    );

    return &this->m_from_seqCmdStatus[portNum];
  }

  // ----------------------------------------------------------------------
  // Component construction and destruction
  // ----------------------------------------------------------------------

  CommandDispatcherTesterBase ::
    CommandDispatcherTesterBase(
        const char* const compName,
        const U32 maxHistorySize
    ) :
      Fw::PassiveComponentBase(compName)
  {
    // Initialize port histories
    this->fromPortHistory_compCmdSend = new History<FromPortEntry_compCmdSend>(maxHistorySize);
    this->fromPortHistory_pingOut = new History<FromPortEntry_pingOut>(maxHistorySize);
    this->fromPortHistory_seqCmdStatus = new History<FromPortEntry_seqCmdStatus>(maxHistorySize);

    // Initialize command history
    this->cmdResponseHistory = new History<CmdResponse>(maxHistorySize);

    // Initialize event histories
#if FW_ENABLE_TEXT_LOGGING
    this->textLogHistory = new History<TextLogEntry>(maxHistorySize);
#endif
    this->eventHistory_OpCodeRegistered = new History<EventEntry_OpCodeRegistered>(maxHistorySize);
    this->eventHistory_OpCodeDispatched = new History<EventEntry_OpCodeDispatched>(maxHistorySize);
    this->eventHistory_OpCodeCompleted = new History<EventEntry_OpCodeCompleted>(maxHistorySize);
    this->eventHistory_OpCodeError = new History<EventEntry_OpCodeError>(maxHistorySize);
    this->eventHistory_MalformedCommand = new History<EventEntry_MalformedCommand>(maxHistorySize);
    this->eventHistory_InvalidCommand = new History<EventEntry_InvalidCommand>(maxHistorySize);
    this->eventHistory_TooManyCommands = new History<EventEntry_TooManyCommands>(maxHistorySize);
    this->eventHistory_NoOpStringReceived = new History<EventEntry_NoOpStringReceived>(maxHistorySize);
    this->eventHistory_TestCmd1Args = new History<EventEntry_TestCmd1Args>(maxHistorySize);
    this->eventHistory_OpCodeReregistered = new History<EventEntry_OpCodeReregistered>(maxHistorySize);

    // Initialize telemetry histories
    this->tlmHistory_CommandsDispatched = new History<TlmEntry_CommandsDispatched>(maxHistorySize);
    this->tlmHistory_CommandErrors = new History<TlmEntry_CommandErrors>(maxHistorySize);

    // Clear history
    this->clearHistory();
  }

  CommandDispatcherTesterBase ::
    ~CommandDispatcherTesterBase()
  {
    // Destroy port histories
    delete this->fromPortHistory_compCmdSend;
    delete this->fromPortHistory_pingOut;
    delete this->fromPortHistory_seqCmdStatus;

    // Destroy command history
    delete this->cmdResponseHistory;

    // Destroy event histories
#if FW_ENABLE_TEXT_LOGGING
    delete this->textLogHistory;
#endif
    delete this->eventHistory_OpCodeRegistered;
    delete this->eventHistory_OpCodeDispatched;
    delete this->eventHistory_OpCodeCompleted;
    delete this->eventHistory_OpCodeError;
    delete this->eventHistory_MalformedCommand;
    delete this->eventHistory_InvalidCommand;
    delete this->eventHistory_TooManyCommands;
    delete this->eventHistory_NoOpStringReceived;
    delete this->eventHistory_TestCmd1Args;
    delete this->eventHistory_OpCodeReregistered;

    // Destroy telemetry histories
    delete this->tlmHistory_CommandsDispatched;
    delete this->tlmHistory_CommandErrors;
  }

  // ----------------------------------------------------------------------
  // Default handler implementations for typed from ports
  // You can override these implementation with more specific behavior
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    from_compCmdSend_handler(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    this->pushFromPortEntry_compCmdSend(opCode, cmdSeq, args);
  }

  void CommandDispatcherTesterBase ::
    from_pingOut_handler(
        FwIndexType portNum,
        U32 key
    )
  {
    this->pushFromPortEntry_pingOut(key);
  }

  void CommandDispatcherTesterBase ::
    from_seqCmdStatus_handler(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    this->pushFromPortEntry_seqCmdStatus(opCode, cmdSeq, response);
  }

  // ----------------------------------------------------------------------
  // Handler base-class functions for from ports
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    from_compCmdSend_handlerBase(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_from_compCmdSend(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_compCmdSend_handler(
      portNum,
      opCode,
      cmdSeq,
      args
    );
  }

  void CommandDispatcherTesterBase ::
    from_pingOut_handlerBase(
        FwIndexType portNum,
        U32 key
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_from_pingOut(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_pingOut_handler(
      portNum,
      key
    );
  }

  void CommandDispatcherTesterBase ::
    from_seqCmdStatus_handlerBase(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_from_seqCmdStatus(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->from_seqCmdStatus_handler(
      portNum,
      opCode,
      cmdSeq,
      response
    );
  }

  // ----------------------------------------------------------------------
  // Invocation functions for to ports
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    invoke_to_compCmdReg(
        FwIndexType portNum,
        FwOpcodeType opCode
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_to_compCmdReg(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_compCmdReg[portNum].invoke(
      opCode
    );
  }

  void CommandDispatcherTesterBase ::
    invoke_to_compCmdStat(
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_to_compCmdStat(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_compCmdStat[portNum].invoke(
      opCode,
      cmdSeq,
      response
    );
  }

  void CommandDispatcherTesterBase ::
    invoke_to_pingIn(
        FwIndexType portNum,
        U32 key
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_to_pingIn(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_pingIn[portNum].invoke(
      key
    );
  }

  void CommandDispatcherTesterBase ::
    invoke_to_seqCmdBuff(
        FwIndexType portNum,
        Fw::ComBuffer& data,
        U32 context
    )
  {
    // Make sure port number is valid
    FW_ASSERT(
      portNum < this->getNum_to_seqCmdBuff(),
      static_cast<FwAssertArgType>(portNum)
    );
    this->m_to_seqCmdBuff[portNum].invoke(
      data,
      context
    );
  }

  // ----------------------------------------------------------------------
  // Getters for port counts
  // ----------------------------------------------------------------------

  FwIndexType CommandDispatcherTesterBase ::
    getNum_to_CmdDisp() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_CmdDisp));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_to_compCmdReg() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_compCmdReg));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_to_compCmdStat() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_compCmdStat));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_to_pingIn() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_pingIn));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_to_seqCmdBuff() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_to_seqCmdBuff));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_CmdReg() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_CmdReg));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_CmdStatus() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_CmdStatus));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_Log() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_Log));
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_LogText() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_LogText));
  }

#endif

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_Time() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_Time));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_Tlm() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_Tlm));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_compCmdSend() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_compCmdSend));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_pingOut() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_pingOut));
  }

  FwIndexType CommandDispatcherTesterBase ::
    getNum_from_seqCmdStatus() const
  {
    return static_cast<FwIndexType>(FW_NUM_ARRAY_ELEMENTS(this->m_from_seqCmdStatus));
  }

  // ----------------------------------------------------------------------
  // Connection status queries for to ports
  // ----------------------------------------------------------------------

  bool CommandDispatcherTesterBase ::
    isConnected_to_CmdDisp(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_to_CmdDisp(),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_CmdDisp[portNum].isConnected();
  }

  bool CommandDispatcherTesterBase ::
    isConnected_to_compCmdReg(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_to_compCmdReg(),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_compCmdReg[portNum].isConnected();
  }

  bool CommandDispatcherTesterBase ::
    isConnected_to_compCmdStat(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_to_compCmdStat(),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_compCmdStat[portNum].isConnected();
  }

  bool CommandDispatcherTesterBase ::
    isConnected_to_pingIn(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_to_pingIn(),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_pingIn[portNum].isConnected();
  }

  bool CommandDispatcherTesterBase ::
    isConnected_to_seqCmdBuff(FwIndexType portNum)
  {
    FW_ASSERT(
      portNum < this->getNum_to_seqCmdBuff(),
      static_cast<FwAssertArgType>(portNum)
    );

    return this->m_to_seqCmdBuff[portNum].isConnected();
  }

  // ----------------------------------------------------------------------
  // Functions for testing commands
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    cmdResponseIn(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdResponse response
    )
  {
    CmdResponse e = { opCode, cmdSeq, response };
    this->cmdResponseHistory->push_back(e);
  }

  void CommandDispatcherTesterBase ::
    sendRawCmd(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& buf
    )
  {
    const U32 idBase = this->getIdBase();
    FwOpcodeType _opcode = opCode + idBase;
    if (this->m_to_CmdDisp[0].isConnected()) {
      this->m_to_CmdDisp[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void CommandDispatcherTesterBase ::
    sendCmd_CMD_NO_OP(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = CommandDispatcherComponentBase::OPCODE_CMD_NO_OP + idBase;

    if (this->m_to_CmdDisp[0].isConnected()) {
      this->m_to_CmdDisp[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void CommandDispatcherTesterBase ::
    sendCmd_CMD_NO_OP_STRING(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        const Fw::StringBase& arg1
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = arg1.serialize(buf, FW_CMD_STRING_MAX_SIZE);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = CommandDispatcherComponentBase::OPCODE_CMD_NO_OP_STRING + idBase;

    if (this->m_to_CmdDisp[0].isConnected()) {
      this->m_to_CmdDisp[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void CommandDispatcherTesterBase ::
    sendCmd_CMD_TEST_CMD_1(
        const FwEnumStoreType instance,
        U32 cmdSeq,
        I32 arg1,
        F32 arg2,
        U8 arg3
    )
  {
    // Serialize arguments
    Fw::CmdArgBuffer buf;
    Fw::SerializeStatus _status;

    _status = buf.serialize(arg1);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(arg2);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = buf.serialize(arg3);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = CommandDispatcherComponentBase::OPCODE_CMD_TEST_CMD_1 + idBase;

    if (this->m_to_CmdDisp[0].isConnected()) {
      this->m_to_CmdDisp[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  void CommandDispatcherTesterBase ::
    sendCmd_CMD_CLEAR_TRACKING(
        const FwEnumStoreType instance,
        U32 cmdSeq
    )
  {
    Fw::CmdArgBuffer buf;

    // Call output command port
    FwOpcodeType _opcode;
    const U32 idBase = this->getIdBase();
    _opcode = CommandDispatcherComponentBase::OPCODE_CMD_CLEAR_TRACKING + idBase;

    if (this->m_to_CmdDisp[0].isConnected()) {
      this->m_to_CmdDisp[0].invoke(
        _opcode,
        cmdSeq,
        buf
      );
    }
    else {
      printf("Test Command Output port not connected!\n");
    }
  }

  // ----------------------------------------------------------------------
  // Functions for testing events
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    dispatchEvents(
        FwEventIdType id,
        const Fw::Time& timeTag,
        const Fw::LogSeverity severity,
        Fw::LogBuffer& args
    )
  {
    args.resetDeser();

    const U32 idBase = this->getIdBase();
    FW_ASSERT(id >= idBase, id, idBase);

    switch (id - idBase) {
      case CommandDispatcherComponentBase::EVENTID_OPCODEREGISTERED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 3, _numArgs, 3);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        I32 port;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(I32), _argSize, sizeof(I32));
        }
#endif
        _status = args.deserialize(port);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        I32 slot;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(I32), _argSize, sizeof(I32));
        }
#endif
        _status = args.deserialize(slot);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_DIAGNOSTIC_OpCodeRegistered(Opcode, port, slot);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_OPCODEDISPATCHED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 2, _numArgs, 2);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        I32 port;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(I32), _argSize, sizeof(I32));
        }
#endif
        _status = args.deserialize(port);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_COMMAND_OpCodeDispatched(Opcode, port);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_OPCODECOMPLETED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_COMMAND_OpCodeCompleted(Opcode);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_OPCODEERROR: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 2, _numArgs, 2);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        Fw::CmdResponse error;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == Fw::CmdResponse::SERIALIZED_SIZE, _argSize, Fw::CmdResponse::SERIALIZED_SIZE);
        }
#endif
        _status = args.deserialize(error);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_COMMAND_OpCodeError(Opcode, error);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_MALFORMEDCOMMAND: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

        Fw::DeserialStatus Status;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == Fw::DeserialStatus::SERIALIZED_SIZE, _argSize, Fw::DeserialStatus::SERIALIZED_SIZE);
        }
#endif
        _status = args.deserialize(Status);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_WARNING_HI_MalformedCommand(Status);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_INVALIDCOMMAND: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_WARNING_HI_InvalidCommand(Opcode);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_TOOMANYCOMMANDS: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_WARNING_HI_TooManyCommands(Opcode);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_NOOPRECEIVED: {
#if FW_AMPCS_COMPATIBLE
        // For AMPCS, decode zero arguments
        Fw::SerializeStatus _zero_status = Fw::FW_SERIALIZE_OK;
        U8 _noArgs;
        _zero_status = args.deserialize(_noArgs);
        FW_ASSERT(
          _zero_status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_zero_status)
        );
#endif
        this->logIn_ACTIVITY_HI_NoOpReceived();
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_NOOPSTRINGRECEIVED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 1, _numArgs, 1);
#endif

        Fw::LogStringArg message;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == Fw::LogStringArg::SERIALIZED_SIZE, _argSize, Fw::LogStringArg::SERIALIZED_SIZE);
        }
#endif
        _status = args.deserialize(message);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_ACTIVITY_HI_NoOpStringReceived(message);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_TESTCMD1ARGS: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 3, _numArgs, 3);
#endif

        I32 arg1;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(I32), _argSize, sizeof(I32));
        }
#endif
        _status = args.deserialize(arg1);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        F32 arg2;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(F32), _argSize, sizeof(F32));
        }
#endif
        _status = args.deserialize(arg2);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        U8 arg3;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U8), _argSize, sizeof(U8));
        }
#endif
        _status = args.deserialize(arg3);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_ACTIVITY_HI_TestCmd1Args(arg1, arg2, arg3);
        break;
      }

      case CommandDispatcherComponentBase::EVENTID_OPCODEREREGISTERED: {
        Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
        // Deserialize the number of arguments.
        U8 _numArgs;
        _status = args.deserialize(_numArgs);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        // Verify they match expected.
        FW_ASSERT(_numArgs == 2, _numArgs, 2);
#endif

        U32 Opcode;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(U32), _argSize, sizeof(U32));
        }
#endif
        _status = args.deserialize(Opcode);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );

        I32 port;
#if FW_AMPCS_COMPATIBLE
        {
          // Deserialize the argument size
          U8 _argSize;
          _status = args.deserialize(_argSize);
          FW_ASSERT(
            _status == Fw::FW_SERIALIZE_OK,
            static_cast<FwAssertArgType>(_status)
          );
          FW_ASSERT(_argSize == sizeof(I32), _argSize, sizeof(I32));
        }
#endif
        _status = args.deserialize(port);
        FW_ASSERT(
          _status == Fw::FW_SERIALIZE_OK,
          static_cast<FwAssertArgType>(_status)
        );
        this->logIn_DIAGNOSTIC_OpCodeReregistered(Opcode, port);
        break;
      }

      default: {
        FW_ASSERT(0, id);
        break;
      }
    }
  }

#if FW_ENABLE_TEXT_LOGGING

  void CommandDispatcherTesterBase ::
    textLogIn(
        FwEventIdType id,
        const Fw::Time& timeTag,
        const Fw::LogSeverity severity,
        const Fw::TextLogString& text
    )
  {
    TextLogEntry e = { id, timeTag, severity, text };
    textLogHistory->push_back(e);
  }

#endif

  void CommandDispatcherTesterBase ::
    logIn_DIAGNOSTIC_OpCodeRegistered(
        U32 Opcode,
        I32 port,
        I32 slot
    )
  {
    EventEntry_OpCodeRegistered _e = {
      Opcode,
      port,
      slot
    };
    eventHistory_OpCodeRegistered->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_COMMAND_OpCodeDispatched(
        U32 Opcode,
        I32 port
    )
  {
    EventEntry_OpCodeDispatched _e = {
      Opcode,
      port
    };
    eventHistory_OpCodeDispatched->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_COMMAND_OpCodeCompleted(U32 Opcode)
  {
    EventEntry_OpCodeCompleted _e = {
      Opcode
    };
    eventHistory_OpCodeCompleted->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_COMMAND_OpCodeError(
        U32 Opcode,
        Fw::CmdResponse error
    )
  {
    EventEntry_OpCodeError _e = {
      Opcode,
      error
    };
    eventHistory_OpCodeError->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_WARNING_HI_MalformedCommand(Fw::DeserialStatus Status)
  {
    EventEntry_MalformedCommand _e = {
      Status
    };
    eventHistory_MalformedCommand->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_WARNING_HI_InvalidCommand(U32 Opcode)
  {
    EventEntry_InvalidCommand _e = {
      Opcode
    };
    eventHistory_InvalidCommand->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_WARNING_HI_TooManyCommands(U32 Opcode)
  {
    EventEntry_TooManyCommands _e = {
      Opcode
    };
    eventHistory_TooManyCommands->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_ACTIVITY_HI_NoOpReceived()
  {
    this->eventsSize_NoOpReceived++;
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_ACTIVITY_HI_NoOpStringReceived(const Fw::StringBase& message)
  {
    EventEntry_NoOpStringReceived _e = {
      message
    };
    eventHistory_NoOpStringReceived->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_ACTIVITY_HI_TestCmd1Args(
        I32 arg1,
        F32 arg2,
        U8 arg3
    )
  {
    EventEntry_TestCmd1Args _e = {
      arg1,
      arg2,
      arg3
    };
    eventHistory_TestCmd1Args->push_back(_e);
    this->eventsSize++;
  }

  void CommandDispatcherTesterBase ::
    logIn_DIAGNOSTIC_OpCodeReregistered(
        U32 Opcode,
        I32 port
    )
  {
    EventEntry_OpCodeReregistered _e = {
      Opcode,
      port
    };
    eventHistory_OpCodeReregistered->push_back(_e);
    this->eventsSize++;
  }

  // ----------------------------------------------------------------------
  // Functions for testing telemetry
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    dispatchTlm(
        FwChanIdType id,
        const Fw::Time& timeTag,
        Fw::TlmBuffer& val
    )
  {
    val.resetDeser();

    const U32 idBase = this->getIdBase();
    FW_ASSERT(id >= idBase, id, idBase);

    switch (id - idBase) {
      case CommandDispatcherComponentBase::CHANNELID_COMMANDSDISPATCHED: {
        U32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing CommandsDispatched: %d\n", _status);
          return;
        }

        this->tlmInput_CommandsDispatched(timeTag, arg);
        break;
      }

      case CommandDispatcherComponentBase::CHANNELID_COMMANDERRORS: {
        U32 arg;
        const Fw::SerializeStatus _status = val.deserialize(arg);

        if (_status != Fw::FW_SERIALIZE_OK) {
          printf("Error deserializing CommandErrors: %d\n", _status);
          return;
        }

        this->tlmInput_CommandErrors(timeTag, arg);
        break;
      }

      default: {
        FW_ASSERT(0, id);
        break;
      }
    }
  }

  void CommandDispatcherTesterBase ::
    tlmInput_CommandsDispatched(
        const Fw::Time& timeTag,
        const U32 val
    )
  {
    TlmEntry_CommandsDispatched e = { timeTag, val };
    this->tlmHistory_CommandsDispatched->push_back(e);
    this->tlmSize++;
  }

  void CommandDispatcherTesterBase ::
    tlmInput_CommandErrors(
        const Fw::Time& timeTag,
        const U32 val
    )
  {
    TlmEntry_CommandErrors e = { timeTag, val };
    this->tlmHistory_CommandErrors->push_back(e);
    this->tlmSize++;
  }

  // ----------------------------------------------------------------------
  // Functions to test time
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    setTestTime(const Fw::Time& timeTag)
  {
    this->m_testTime = timeTag;
  }

  // ----------------------------------------------------------------------
  // History functions
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    clearHistory()
  {
    this->clearFromPortHistory();
    this->cmdResponseHistory->clear();
#if FW_ENABLE_TEXT_LOGGING
    this->textLogHistory->clear();
#endif
    this->clearEvents();
    this->clearTlm();
  }

  void CommandDispatcherTesterBase ::
    clearFromPortHistory()
  {
    this->fromPortHistorySize = 0;
    this->fromPortHistory_compCmdSend->clear();
    this->fromPortHistory_pingOut->clear();
    this->fromPortHistory_seqCmdStatus->clear();
  }

  void CommandDispatcherTesterBase ::
    pushFromPortEntry_compCmdSend(
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    FromPortEntry_compCmdSend _e;
    _e.opCode = opCode;
    _e.cmdSeq = cmdSeq;
    _e.args = args;
    this->fromPortHistory_compCmdSend->push_back(_e);
    this->fromPortHistorySize++;
  }

  void CommandDispatcherTesterBase ::
    pushFromPortEntry_pingOut(U32 key)
  {
    FromPortEntry_pingOut _e;
    _e.key = key;
    this->fromPortHistory_pingOut->push_back(_e);
    this->fromPortHistorySize++;
  }

  void CommandDispatcherTesterBase ::
    pushFromPortEntry_seqCmdStatus(
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    FromPortEntry_seqCmdStatus _e;
    _e.opCode = opCode;
    _e.cmdSeq = cmdSeq;
    _e.response = response;
    this->fromPortHistory_seqCmdStatus->push_back(_e);
    this->fromPortHistorySize++;
  }

  void CommandDispatcherTesterBase ::
    clearEvents()
  {
    this->eventsSize = 0;
    this->eventHistory_OpCodeRegistered->clear();
    this->eventHistory_OpCodeDispatched->clear();
    this->eventHistory_OpCodeCompleted->clear();
    this->eventHistory_OpCodeError->clear();
    this->eventHistory_MalformedCommand->clear();
    this->eventHistory_InvalidCommand->clear();
    this->eventHistory_TooManyCommands->clear();
    this->eventsSize_NoOpReceived = 0;
    this->eventHistory_NoOpStringReceived->clear();
    this->eventHistory_TestCmd1Args->clear();
    this->eventHistory_OpCodeReregistered->clear();
  }

#if FW_ENABLE_TEXT_LOGGING

  void CommandDispatcherTesterBase ::
    printTextLogHistoryEntry(
        const TextLogEntry& e,
        FILE* file
    )
  {
    const char* severityString = "UNKNOWN";

    switch (e.severity.e) {
      case Fw::LogSeverity::FATAL:
        severityString = "FATAL";
        break;
      case Fw::LogSeverity::WARNING_HI:
        severityString = "WARNING_HI";
        break;
      case Fw::LogSeverity::WARNING_LO:
        severityString = "WARNING_LO";
        break;
      case Fw::LogSeverity::COMMAND:
        severityString = "COMMAND";
        break;
      case Fw::LogSeverity::ACTIVITY_HI:
        severityString = "ACTIVITY_HI";
        break;
      case Fw::LogSeverity::ACTIVITY_LO:
        severityString = "ACTIVITY_LO";
        break;
      case Fw::LogSeverity::DIAGNOSTIC:
       severityString = "DIAGNOSTIC";
        break;
      default:
        severityString = "SEVERITY ERROR";
        break;
    }

    fprintf(
      file,
      "EVENT: (%" PRI_FwEventIdType ") (%" PRI_FwTimeBaseStoreType ":%" PRIu32 ",%" PRIu32 ") %s: %s\n",
      e.id,
      static_cast<FwTimeBaseStoreType>(e.timeTag.getTimeBase()),
      e.timeTag.getSeconds(),
      e.timeTag.getUSeconds(),
      severityString,
      e.text.toChar()
    );
  }

  void CommandDispatcherTesterBase ::
    printTextLogHistory(FILE* const file)
  {
    for (U32 i = 0; i < this->textLogHistory->size(); i++) {
      this->printTextLogHistoryEntry(
        this->textLogHistory->at(i),
        file
      );
    }
  }

#endif

  void CommandDispatcherTesterBase ::
    clearTlm()
  {
    this->tlmSize = 0;
    this->tlmHistory_CommandsDispatched->clear();
    this->tlmHistory_CommandErrors->clear();
  }

  // ----------------------------------------------------------------------
  // Static functions for output ports
  // ----------------------------------------------------------------------

  void CommandDispatcherTesterBase ::
    from_CmdReg_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode
    )
  {

  }

  void CommandDispatcherTesterBase ::
    from_CmdStatus_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->cmdResponseIn(opCode, cmdSeq, response);
  }

  void CommandDispatcherTesterBase ::
    from_Log_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwEventIdType id,
        Fw::Time& timeTag,
        const Fw::LogSeverity& severity,
        Fw::LogBuffer& args
    )
  {
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->dispatchEvents(id, timeTag, severity, args);
  }

#if FW_ENABLE_TEXT_LOGGING == 1

  void CommandDispatcherTesterBase ::
    from_LogText_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwEventIdType id,
        Fw::Time& timeTag,
        const Fw::LogSeverity& severity,
        Fw::TextLogString& text
    )
  {
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->textLogIn(id, timeTag, severity, text);
  }

#endif

  void CommandDispatcherTesterBase ::
    from_Time_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        Fw::Time& time
    )
  {
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    time = _testerBase->m_testTime;
  }

  void CommandDispatcherTesterBase ::
    from_Tlm_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwChanIdType id,
        Fw::Time& timeTag,
        Fw::TlmBuffer& val
    )
  {
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->dispatchTlm(id, timeTag, val);
  }

  void CommandDispatcherTesterBase ::
    from_compCmdSend_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        Fw::CmdArgBuffer& args
    )
  {
    FW_ASSERT(callComp != nullptr);
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->from_compCmdSend_handlerBase(
      portNum,
      opCode,
      cmdSeq,
      args
    );
  }

  void CommandDispatcherTesterBase ::
    from_pingOut_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        U32 key
    )
  {
    FW_ASSERT(callComp != nullptr);
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->from_pingOut_handlerBase(
      portNum,
      key
    );
  }

  void CommandDispatcherTesterBase ::
    from_seqCmdStatus_static(
        Fw::PassiveComponentBase* const callComp,
        FwIndexType portNum,
        FwOpcodeType opCode,
        U32 cmdSeq,
        const Fw::CmdResponse& response
    )
  {
    FW_ASSERT(callComp != nullptr);
    CommandDispatcherTesterBase* _testerBase = static_cast<CommandDispatcherTesterBase*>(callComp);
    _testerBase->from_seqCmdStatus_handlerBase(
      portNum,
      opCode,
      cmdSeq,
      response
    );
  }

}
