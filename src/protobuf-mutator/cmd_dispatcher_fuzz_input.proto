syntax = "proto3";

package Svc;

// F-Prime의 기본 CmdResponse 열거형 모방
enum CmdResponseEnum {
  OK = 0;
  VALIDATION_ERROR = 1;
  FORMAT_ERROR = 2; // Fw::ComPacket::deserialize 에서 발생 가능한 오류
  INVALID_OPCODE = 3;
  BUSY = 4; // Fw::CmdResponse에는 없지만, 유사한 개념
  EXECUTION_ERROR = 5;
  TIMEOUT = 6; // Fw::CmdResponse에는 없지만, 유사한 개념
  REROUTED = 7; // Fw::CmdResponse에는 없지만, 유사한 개념
  BAD_LENGTH = 8; // Fw::ComPacket::deserialize 에서 발생 가능한 오류
  TYPE_MISMATCH = 9; // Fw::ComPacket::deserialize 에서 발생 가능한 오류 (DeserialStatus)
}

// F-Prime의 Packet Descriptor Type 모방
enum PacketDescriptorType {
  FW_PACKET_COMMAND = 0;
  FW_PACKET_TELEM = 1;
  FW_PACKET_FILE = 2;
  FW_PACKET_LOG = 3;
  FW_PACKET_FATAL = 4;
  FW_PACKET_UNKNOWN = 99; // Fuzzer가 임의의 값을 생성하도록 허용
}

// 실제 Fw::CmdArgBuffer는 직렬화된 바이너리 데이터이므로, 여기서는 bytes로 표현
message CommandArguments {
  bytes arg_data = 1; // 직렬화된 커맨드 인자들
}

// CmdPacket의 내용을 모방. 실제 Fw::CmdPacket은 바이너리 직렬화 형식임.
// Fuzzer가 더 쉽게 다양한 데이터를 생성하도록 필드를 나눔.
message FuzzedCmdPacket {
  PacketDescriptorType desc_type = 1; // 패킷 디스크립터 타입 (원래 U32)
  uint32 opcode = 2;                  // Opcode
  CommandArguments arguments = 3;     // 커맨드 인자
}

// seqCmdBuff 포트로 들어가는 Fw::ComBuffer의 내용을 모방
message CommandBufferInput {
  FuzzedCmdPacket packet_content = 1; // 직렬화될 CmdPacket 내용
  uint32 context = 2;                 // seqCmdBuff 핸들러의 context 파라미터
  bool simulate_serialization_failure = 3; // true면 packet_content 대신 임의의 바이트 시퀀스를 사용
  bytes raw_buffer_override = 4; // simulate_serialization_failure가 true일 때 사용될 바이트 시퀀스
}

// compCmdReg 포트로 들어가는 Opcode 등록 요청
message CommandRegistrationInput {
  uint32 opcode_to_register = 1;
  // portNum은 FuzzTester 내부에서 결정될 수 있으므로, 여기서는 Opcode만
}

// CmdDispatcherImpl의 내장 커맨드 실행 시나리오
message InternalCommandScenario {
  enum CommandType {
    NO_OP = 0;
    NO_OP_STRING = 1;
    TEST_CMD_1 = 2;
    CLEAR_TRACKING = 3;
  }
  CommandType command_type = 1;
  string no_op_string_arg = 2; // For NO_OP_STRING
  int32 test_cmd_arg1_i32 = 3; // For TEST_CMD_1
  float test_cmd_arg2_f32 = 4; // For TEST_CMD_1
  uint32 test_cmd_arg3_u8 = 5; // For TEST_CMD_1 (proto3는 u8이 없으므로 u32 사용)
}

// compCmdStat 포트를 통해 응답을 시뮬레이션하기 위한 정보
message CommandStatusInput {
  uint32 opcode = 1;
  uint32 cmd_seq = 2; // 이 값은 FuzzTester가 내부적으로 관리하는 m_cmdSendCmdSeq를 사용해야 할 수 있음
  CmdResponseEnum response_enum = 3;
  bool use_fuzzed_cmd_seq = 4; // true면 아래 fuzzed_cmd_seq 사용, false면 내부 m_cmdSendCmdSeq
  uint32 fuzzed_cmd_seq = 5;
}

// 하나의 퍼징 입력 단위. 다양한 종류의 액션을 포함할 수 있음.
message CmdDispatcherFuzzAction {
  oneof action_type {
    CommandBufferInput send_cmd_buffer = 1;
    CommandRegistrationInput register_cmd = 2;
    InternalCommandScenario internal_cmd = 3; // CmdDispatcher의 자체 커맨드 실행 (NO_OP 등)
    CommandStatusInput simulate_cmd_status = 4; // compCmdStat을 통해 응답 시뮬레이션
    // 향후 Ping 테스트 등 다른 액션 추가 가능
    // bool send_ping = 5;
  }
}

// 퍼저가 생성할 최상위 메시지. 여러 액션의 시퀀스를 포함할 수 있음.
message CmdDispatcherFuzzInput {
  // 한 번의 퍼징 시도에서 실행할 액션들의 시퀀스
  repeated CmdDispatcherFuzzAction actions = 1;

  // 전역적인 설정 (예: CmdDispatcherImpl 초기화 파라미터) - 필요시 추가
  uint32 initial_queue_depth = 2;
  uint32 initial_instance_id = 3;
} 